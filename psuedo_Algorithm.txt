4 3 5
1 1 0 0
0 1 1 0
0 0 1 1
1 0 0 1
0 1 0 1
This represents:
• 4 exams, 3 time slots, 5 students
• Student 0: enrolled in exams {0, 1}
• Student 1: enrolled in exams {1, 2}
• Student 2: enrolled in exams {2, 3}
• Student 3: enrolled in exams {0, 3}
• Student 4: enrolled in exams {1, 3}

Objective is to find an assignment of exams to time slots that 
* no student has two exams scheduled in the same time slot, 
* minimizes total number of consecutive exams for students

- Given the above example, where N=4, K=3, and M=5

Chromosome representation of the exam schedule could be 
	       [slot(1)], [slot(2)], [slot(n)]
- chromosome = { exam(1), exam(2), exam(n) }
- chromosome = ( 2, 3, 2, 1 }
*means  exam 4 is in slot 1, exam 1 and 3 are in slot 2, exam 2 is in slot 3

-this chromosome representation of the exam timetable satisfies the scenario with the matrix E above.



Pseudocode

----------

1) initialise population:

for each individual:
    for each exam:
        assign random slot in [0, K-1]

2) Pick tournament size:

pick 3 random individuals
return best fitness

3) Crossover (single point crossover)

cut = random index
child = parent1[:cut] + parent2[cut:]

4) Mutation (can experiment with small -> large mutation)

if random < mutation_rate:
    assign new random slot

5) Elitism 

new_population[0] = best_solution

6) Main GA loop

population = initialize()

for generation in generations:
    evaluate fitness
    record best fitness

    new_population = []

    while new_population not full:
        parent1 = select()
        parent2 = select()

        if random < crossover_rate:
            child = crossover()
        else:
            child = copy(parent)

        mutate(child)
        new_population.append(child)

    apply elitism
    population = new_population



------------------

Solution

------------------

*Best individual chromosome*

One with least soft violations and no hard violations (best fitness)

1)Hard violation measure

seen_slots = list()

for exam in student_exams:
    slot = solution[exam]
    if slot in seen_slots:
        hard_violations += 1
    else:
        seen_slots.add(slot)

2) Soft constraint measure

slots = sorted(student_exam_slots)

for i in range(len(slots)-1):
    if slots[i+1] == slots[i] + 1:
        soft_penalty += 1


3) Fitness function

fitness = - (100 * hard_violations + soft_penalty)
* because a hard violation is much less acceptable than a soft violation*



